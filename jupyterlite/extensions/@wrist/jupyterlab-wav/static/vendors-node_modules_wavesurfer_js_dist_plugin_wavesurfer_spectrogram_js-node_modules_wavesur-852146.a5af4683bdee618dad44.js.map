{"version":3,"file":"vendors-node_modules_wavesurfer_js_dist_plugin_wavesurfer_spectrogram_js-node_modules_wavesur-852146.a5af4683bdee618dad44.js","mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAyD;AAC7D;AACA,MAAM,EAKyF;AAC/F,CAAC;AACD,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;;AAEA;;AAEA;AACA,kBAAkB,gBAAgB;AAClC;AACA;;AAEA;;AAEA;AACA;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;;AAEA;;AAEA;AACA,kBAAkB,gBAAgB;AAClC;AACA;;AAEA;;AAEA;AACA;;AAEA,kBAAkB,gBAAgB;AAClC;AACA;;AAEA;;AAEA;AACA,kBAAkB,gBAAgB;AAClC;AACA;;AAEA;;AAEA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;;AAEA;;AAEA;AACA,kBAAkB,gBAAgB;AAClC;AACA;;AAEA;;AAEA;AACA,kBAAkB,gBAAgB;AAClC;AACA;;AAEA;;AAEA;AACA,kBAAkB,gBAAgB;AAClC;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,WAAW;AAC3B;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,gBAAgB;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,gBAAgB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,oBAAoB;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wCAAwC,OAAO;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAO;;AAEP;AACA;AACA;AACA;AACA,yBAAyB,+BAAmB;;;;AAI5C;AACA;AACA,CAAC;AACD;;AAEA,kCAAkC,+BAAmB;;AAErD,uCAAuC,uCAAuC;;AAE9E,kDAAkD,0CAA0C;;AAE5F,4CAA4C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD;;AAE/P,8DAA8D,sEAAsE,8DAA8D,kDAAkD,iBAAiB,GAAG;;AAExQ;AACA,aAAa,QAAQ;AACrB,cAAc,oBAAoB;AAClC;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB;AACA,cAAc,QAAQ;AACtB;AACA;AACA,cAAc,SAAS;AACvB;AACA,cAAc,QAAQ;AACtB;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA,cAAc,UAAU;AACxB;AACA,cAAc,aAAa;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB,4BAA4B;AACpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;;AAEA,yBAAyB,UAAU;AACnC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF;AACrF;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4DAA4D;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;;AAGV;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA,sBAAsB,4BAA4B;AAClD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,oBAAoB;AAC1C;AACA;;AAEA,mCAAmC;;AAEnC;AACA;;AAEA,uCAAuC;AACvC;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;;AAE/D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C;;AAE5C;AACA;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA,YAAY;AACZ,2DAA2D;;AAE3D;AACA;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,oBAAoB,yBAAyB;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;AACA;;AAEA,OAAO;;AAEP,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,mBAAmB,gCAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,gCAAmB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gCAAmB;AACvD;AACA;AACA,UAAU;AACV;AACA,CAAC;AACD;;;;;;;;;;AC3zBA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAyD;AAC7D;AACA,MAAM,EAKsF;AAC5F,CAAC;AACD,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA,CAAC;AACD;;AAEA,kDAAkD,0CAA0C;;AAE5F,4CAA4C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD;;AAE/P,8DAA8D,sEAAsE,8DAA8D,kDAAkD,iBAAiB,GAAG;;AAExQ,4CAA4C,kBAAkB,kCAAkC,oEAAoE,KAAK,OAAO,oBAAoB;;AAEpM;AACA,aAAa,QAAQ;AACrB;AACA,cAAc,qBAAqB;AACnC;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,QAAQ;AACtB,cAAc,SAAS;AACvB;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,SAAS;AACvB;AACA,cAAc,UAAU;AACxB,cAAc,UAAU;AACxB,cAAc,UAAU;AACxB;AACA,cAAc,UAAU;AACxB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,UAAU;AACxB;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sBAAsB;AACnC,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,4HAA4H;;AAE5H;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6KAA6K;;AAE7K,wDAAwD;AACxD;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA,4BAA4B;;AAE5B;;AAEA,kBAAkB,kCAAkC;AACpD;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;AACA,SAAS;AACT,SAAS;;;AAGT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO,GAAG;;AAEV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO,GAAG;;AAEV;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,eAAe,wCAAwC;AACvD;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;;AAEA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,8CAA8C;;AAE9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB,QAAQ;AACzB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN,GAAG;;AAEH;AACA,CAAC;;AAED;AACA;;AAEA,OAAO;;AAEP,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,mBAAmB,gCAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,gCAAmB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gCAAmB;AACvD;AACA;AACA,UAAU;AACV;AACA,CAAC;AACD","sources":["webpack://@wrist/jupyterlab-wav/./node_modules/wavesurfer.js/dist/plugin/wavesurfer.spectrogram.js","webpack://@wrist/jupyterlab-wav/./node_modules/wavesurfer.js/dist/plugin/wavesurfer.timeline.js"],"sourcesContent":["/*!\n * wavesurfer.js spectrogram plugin 6.2.0 (2022-05-16)\n * https://wavesurfer-js.org\n * @license BSD-3-Clause\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"WaveSurfer\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WaveSurfer\"] = factory();\n\telse\n\t\troot[\"WaveSurfer\"] = root[\"WaveSurfer\"] || {}, root[\"WaveSurfer\"][\"spectrogram\"] = factory();\n})(self, () => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ \"./src/plugin/spectrogram/fft.js\":\n/*!***************************************!*\\\n  !*** ./src/plugin/spectrogram/fft.js ***!\n  \\***************************************/\n/***/ ((module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = FFT;\n\n/* eslint-disable complexity, no-redeclare, no-var, one-var */\n\n/**\n * Calculate FFT - Based on https://github.com/corbanbrook/dsp.js\n *\n * @param {Number} bufferSize Buffer size\n * @param {Number} sampleRate Sample rate\n * @param {Function} windowFunc Window function\n * @param {Number} alpha Alpha channel\n */\nfunction FFT(bufferSize, sampleRate, windowFunc, alpha) {\n  this.bufferSize = bufferSize;\n  this.sampleRate = sampleRate;\n  this.bandwidth = 2 / bufferSize * (sampleRate / 2);\n  this.sinTable = new Float32Array(bufferSize);\n  this.cosTable = new Float32Array(bufferSize);\n  this.windowValues = new Float32Array(bufferSize);\n  this.reverseTable = new Uint32Array(bufferSize);\n  this.peakBand = 0;\n  this.peak = 0;\n  var i;\n\n  switch (windowFunc) {\n    case 'bartlett':\n      for (i = 0; i < bufferSize; i++) {\n        this.windowValues[i] = 2 / (bufferSize - 1) * ((bufferSize - 1) / 2 - Math.abs(i - (bufferSize - 1) / 2));\n      }\n\n      break;\n\n    case 'bartlettHann':\n      for (i = 0; i < bufferSize; i++) {\n        this.windowValues[i] = 0.62 - 0.48 * Math.abs(i / (bufferSize - 1) - 0.5) - 0.38 * Math.cos(Math.PI * 2 * i / (bufferSize - 1));\n      }\n\n      break;\n\n    case 'blackman':\n      alpha = alpha || 0.16;\n\n      for (i = 0; i < bufferSize; i++) {\n        this.windowValues[i] = (1 - alpha) / 2 - 0.5 * Math.cos(Math.PI * 2 * i / (bufferSize - 1)) + alpha / 2 * Math.cos(4 * Math.PI * i / (bufferSize - 1));\n      }\n\n      break;\n\n    case 'cosine':\n      for (i = 0; i < bufferSize; i++) {\n        this.windowValues[i] = Math.cos(Math.PI * i / (bufferSize - 1) - Math.PI / 2);\n      }\n\n      break;\n\n    case 'gauss':\n      alpha = alpha || 0.25;\n\n      for (i = 0; i < bufferSize; i++) {\n        this.windowValues[i] = Math.pow(Math.E, -0.5 * Math.pow((i - (bufferSize - 1) / 2) / (alpha * (bufferSize - 1) / 2), 2));\n      }\n\n      break;\n\n    case 'hamming':\n      for (i = 0; i < bufferSize; i++) {\n        this.windowValues[i] = 0.54 - 0.46 * Math.cos(Math.PI * 2 * i / (bufferSize - 1));\n      }\n\n      break;\n\n    case 'hann':\n    case undefined:\n      for (i = 0; i < bufferSize; i++) {\n        this.windowValues[i] = 0.5 * (1 - Math.cos(Math.PI * 2 * i / (bufferSize - 1)));\n      }\n\n      break;\n\n    case 'lanczoz':\n      for (i = 0; i < bufferSize; i++) {\n        this.windowValues[i] = Math.sin(Math.PI * (2 * i / (bufferSize - 1) - 1)) / (Math.PI * (2 * i / (bufferSize - 1) - 1));\n      }\n\n      break;\n\n    case 'rectangular':\n      for (i = 0; i < bufferSize; i++) {\n        this.windowValues[i] = 1;\n      }\n\n      break;\n\n    case 'triangular':\n      for (i = 0; i < bufferSize; i++) {\n        this.windowValues[i] = 2 / bufferSize * (bufferSize / 2 - Math.abs(i - (bufferSize - 1) / 2));\n      }\n\n      break;\n\n    default:\n      throw Error(\"No such window function '\" + windowFunc + \"'\");\n  }\n\n  var limit = 1;\n  var bit = bufferSize >> 1;\n  var i;\n\n  while (limit < bufferSize) {\n    for (i = 0; i < limit; i++) {\n      this.reverseTable[i + limit] = this.reverseTable[i] + bit;\n    }\n\n    limit = limit << 1;\n    bit = bit >> 1;\n  }\n\n  for (i = 0; i < bufferSize; i++) {\n    this.sinTable[i] = Math.sin(-Math.PI / i);\n    this.cosTable[i] = Math.cos(-Math.PI / i);\n  }\n\n  this.calculateSpectrum = function (buffer) {\n    // Locally scope variables for speed up\n    var bufferSize = this.bufferSize,\n        cosTable = this.cosTable,\n        sinTable = this.sinTable,\n        reverseTable = this.reverseTable,\n        real = new Float32Array(bufferSize),\n        imag = new Float32Array(bufferSize),\n        bSi = 2 / this.bufferSize,\n        sqrt = Math.sqrt,\n        rval,\n        ival,\n        mag,\n        spectrum = new Float32Array(bufferSize / 2);\n    var k = Math.floor(Math.log(bufferSize) / Math.LN2);\n\n    if (Math.pow(2, k) !== bufferSize) {\n      throw 'Invalid buffer size, must be a power of 2.';\n    }\n\n    if (bufferSize !== buffer.length) {\n      throw 'Supplied buffer is not the same size as defined FFT. FFT Size: ' + bufferSize + ' Buffer Size: ' + buffer.length;\n    }\n\n    var halfSize = 1,\n        phaseShiftStepReal,\n        phaseShiftStepImag,\n        currentPhaseShiftReal,\n        currentPhaseShiftImag,\n        off,\n        tr,\n        ti,\n        tmpReal;\n\n    for (var i = 0; i < bufferSize; i++) {\n      real[i] = buffer[reverseTable[i]] * this.windowValues[reverseTable[i]];\n      imag[i] = 0;\n    }\n\n    while (halfSize < bufferSize) {\n      phaseShiftStepReal = cosTable[halfSize];\n      phaseShiftStepImag = sinTable[halfSize];\n      currentPhaseShiftReal = 1;\n      currentPhaseShiftImag = 0;\n\n      for (var fftStep = 0; fftStep < halfSize; fftStep++) {\n        var i = fftStep;\n\n        while (i < bufferSize) {\n          off = i + halfSize;\n          tr = currentPhaseShiftReal * real[off] - currentPhaseShiftImag * imag[off];\n          ti = currentPhaseShiftReal * imag[off] + currentPhaseShiftImag * real[off];\n          real[off] = real[i] - tr;\n          imag[off] = imag[i] - ti;\n          real[i] += tr;\n          imag[i] += ti;\n          i += halfSize << 1;\n        }\n\n        tmpReal = currentPhaseShiftReal;\n        currentPhaseShiftReal = tmpReal * phaseShiftStepReal - currentPhaseShiftImag * phaseShiftStepImag;\n        currentPhaseShiftImag = tmpReal * phaseShiftStepImag + currentPhaseShiftImag * phaseShiftStepReal;\n      }\n\n      halfSize = halfSize << 1;\n    }\n\n    for (var i = 0, N = bufferSize / 2; i < N; i++) {\n      rval = real[i];\n      ival = imag[i];\n      mag = bSi * sqrt(rval * rval + ival * ival);\n\n      if (mag > this.peak) {\n        this.peakBand = i;\n        this.peak = mag;\n      }\n\n      spectrum[i] = mag;\n    }\n\n    return spectrum;\n  };\n}\n\nmodule.exports = exports.default;\n\n/***/ }),\n\n/***/ \"./src/plugin/spectrogram/index.js\":\n/*!*****************************************!*\\\n  !*** ./src/plugin/spectrogram/index.js ***!\n  \\*****************************************/\n/***/ ((module, exports, __webpack_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _fft = _interopRequireDefault(__webpack_require__(/*! ./fft */ \"./src/plugin/spectrogram/fft.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n/**\n * @typedef {Object} SpectrogramPluginParams\n * @property {string|HTMLElement} container Selector of element or element in\n * which to render\n * @property {number} fftSamples=512 Number of samples to fetch to FFT. Must be\n * a power of 2.\n * @property {boolean} splitChannels=false Render with separate spectrograms for\n * the channels of the audio\n * @property {number} height=fftSamples/2 Height of the spectrogram view in CSS\n * pixels\n * @property {boolean} labels Set to true to display frequency labels.\n * @property {number} noverlap Size of the overlapping window. Must be <\n * fftSamples. Auto deduced from canvas size by default.\n * @property {string} windowFunc='hann' The window function to be used. One of\n * these: `'bartlett'`, `'bartlettHann'`, `'blackman'`, `'cosine'`, `'gauss'`,\n * `'hamming'`, `'hann'`, `'lanczoz'`, `'rectangular'`, `'triangular'`\n * @property {?number} alpha Some window functions have this extra value.\n * (Between 0 and 1)\n * @property {number} pixelRatio=wavesurfer.params.pixelRatio to control the\n * size of the spectrogram in relation with its canvas. 1 = Draw on the whole\n * canvas. 2 = Draw on a quarter (1/2 the length and 1/2 the width)\n * @property {number} frequencyMin=0 Min frequency to scale spectrogram.\n * @property {number} frequencyMax=12000 Max frequency to scale spectrogram.\n * Set this to samplerate/2 to draw whole range of spectrogram.\n * @property {?boolean} deferInit Set to true to manually call\n * `initPlugin('spectrogram')`\n * @property {?number[][]} colorMap A 256 long array of 4-element arrays.\n * Each entry should contain a float between 0 and 1 and specify\n * r, g, b, and alpha.\n */\n\n/**\n * Render a spectrogram visualisation of the audio.\n *\n * @implements {PluginClass}\n * @extends {Observer}\n * @example\n * // es6\n * import SpectrogramPlugin from 'wavesurfer.spectrogram.js';\n *\n * // commonjs\n * var SpectrogramPlugin = require('wavesurfer.spectrogram.js');\n *\n * // if you are using <script> tags\n * var SpectrogramPlugin = window.WaveSurfer.spectrogram;\n *\n * // ... initialising wavesurfer with the plugin\n * var wavesurfer = WaveSurfer.create({\n *   // wavesurfer options ...\n *   plugins: [\n *     SpectrogramPlugin.create({\n *       // plugin options ...\n *     })\n *   ]\n * });\n */\nvar SpectrogramPlugin = /*#__PURE__*/function () {\n  function SpectrogramPlugin(params, ws) {\n    var _this = this;\n\n    _classCallCheck(this, SpectrogramPlugin);\n\n    this.params = params;\n    this.wavesurfer = ws;\n    this.util = ws.util;\n    this.frequenciesDataUrl = params.frequenciesDataUrl;\n\n    this._onScroll = function (e) {\n      _this.updateScroll(e);\n    };\n\n    this._onRender = function () {\n      _this.render();\n    };\n\n    this._onWrapperClick = function (e) {\n      _this._wrapperClickHandler(e);\n    };\n\n    this._onReady = function () {\n      var drawer = _this.drawer = ws.drawer;\n      _this.container = 'string' == typeof params.container ? document.querySelector(params.container) : params.container;\n\n      if (!_this.container) {\n        throw Error('No container for WaveSurfer spectrogram');\n      }\n\n      if (params.colorMap) {\n        if (params.colorMap.length < 256) {\n          throw new Error('Colormap must contain 256 elements');\n        }\n\n        for (var i = 0; i < params.colorMap.length; i++) {\n          var cmEntry = params.colorMap[i];\n\n          if (cmEntry.length !== 4) {\n            throw new Error('ColorMap entries must contain 4 values');\n          }\n        }\n\n        _this.colorMap = params.colorMap;\n      } else {\n        _this.colorMap = [];\n\n        for (var _i = 0; _i < 256; _i++) {\n          var val = (255 - _i) / 256;\n\n          _this.colorMap.push([val, val, val, 1]);\n        }\n      }\n\n      _this.width = drawer.width;\n      _this.pixelRatio = _this.params.pixelRatio || ws.params.pixelRatio;\n      _this.fftSamples = _this.params.fftSamples || ws.params.fftSamples || 512;\n      _this.height = _this.params.height || _this.fftSamples / 2;\n      _this.noverlap = params.noverlap;\n      _this.windowFunc = params.windowFunc;\n      _this.alpha = params.alpha;\n      _this.splitChannels = params.splitChannels;\n      _this.channels = _this.splitChannels ? ws.backend.buffer.numberOfChannels : 1; // Getting file's original samplerate is difficult(#1248).\n      // So set 12kHz default to render like wavesurfer.js 5.x.\n\n      _this.frequencyMin = params.frequencyMin || 0;\n      _this.frequencyMax = params.frequencyMax || 12000;\n\n      _this.createWrapper();\n\n      _this.createCanvas();\n\n      _this.render();\n\n      drawer.wrapper.addEventListener('scroll', _this._onScroll);\n      ws.on('redraw', _this._onRender);\n    };\n  }\n\n  _createClass(SpectrogramPlugin, [{\n    key: \"init\",\n    value: function init() {\n      // Check if wavesurfer is ready\n      if (this.wavesurfer.isReady) {\n        this._onReady();\n      } else {\n        this.wavesurfer.once('ready', this._onReady);\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.unAll();\n      this.wavesurfer.un('ready', this._onReady);\n      this.wavesurfer.un('redraw', this._onRender);\n      this.drawer && this.drawer.wrapper.removeEventListener('scroll', this._onScroll);\n      this.wavesurfer = null;\n      this.util = null;\n      this.params = null;\n\n      if (this.wrapper) {\n        this.wrapper.removeEventListener('click', this._onWrapperClick);\n        this.wrapper.parentNode.removeChild(this.wrapper);\n        this.wrapper = null;\n      }\n    }\n  }, {\n    key: \"createWrapper\",\n    value: function createWrapper() {\n      var prevSpectrogram = this.container.querySelector('spectrogram');\n\n      if (prevSpectrogram) {\n        this.container.removeChild(prevSpectrogram);\n      }\n\n      var wsParams = this.wavesurfer.params;\n      this.wrapper = document.createElement('spectrogram'); // if labels are active\n\n      if (this.params.labels) {\n        var labelsEl = this.labelsEl = document.createElement('canvas');\n        labelsEl.classList.add('spec-labels');\n        this.drawer.style(labelsEl, {\n          position: 'fixed',\n          zIndex: 9,\n          height: \"\".concat(this.height * this.channels, \"px\"),\n          width: \"55px\"\n        });\n        this.wrapper.appendChild(labelsEl);\n        this.loadLabels('rgba(68,68,68,0.5)', '12px', '10px', '', '#fff', '#f7f7f7', 'center', '#specLabels');\n      }\n\n      this.drawer.style(this.wrapper, {\n        display: 'block',\n        position: 'relative',\n        userSelect: 'none',\n        webkitUserSelect: 'none',\n        height: \"\".concat(this.height * this.channels, \"px\")\n      });\n\n      if (wsParams.fillParent || wsParams.scrollParent) {\n        this.drawer.style(this.wrapper, {\n          width: '100%',\n          overflowX: 'hidden',\n          overflowY: 'hidden'\n        });\n      }\n\n      this.container.appendChild(this.wrapper);\n      this.wrapper.addEventListener('click', this._onWrapperClick);\n    }\n  }, {\n    key: \"_wrapperClickHandler\",\n    value: function _wrapperClickHandler(event) {\n      event.preventDefault();\n      var relX = 'offsetX' in event ? event.offsetX : event.layerX;\n      this.fireEvent('click', relX / this.width || 0);\n    }\n  }, {\n    key: \"createCanvas\",\n    value: function createCanvas() {\n      var canvas = this.canvas = this.wrapper.appendChild(document.createElement('canvas'));\n      this.spectrCc = canvas.getContext('2d');\n      this.util.style(canvas, {\n        position: 'absolute',\n        zIndex: 4\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.updateCanvasStyle();\n\n      if (this.frequenciesDataUrl) {\n        this.loadFrequenciesData(this.frequenciesDataUrl);\n      } else {\n        this.getFrequencies(this.drawSpectrogram);\n      }\n    }\n  }, {\n    key: \"updateCanvasStyle\",\n    value: function updateCanvasStyle() {\n      var width = Math.round(this.width / this.pixelRatio) + 'px';\n      this.canvas.width = this.width;\n      this.canvas.height = this.fftSamples / 2 * this.channels;\n      this.canvas.style.width = width;\n      this.canvas.style.height = this.height + 'px';\n    }\n  }, {\n    key: \"drawSpectrogram\",\n    value: function drawSpectrogram(frequenciesData, my) {\n      if (!isNaN(frequenciesData[0][0])) {\n        // data is 1ch [sample, freq] format\n        // to [channel, sample, freq] format\n        frequenciesData = [frequenciesData];\n      }\n\n      var spectrCc = my.spectrCc;\n      var height = my.fftSamples / 2;\n      var width = my.width;\n      var freqFrom = my.buffer.sampleRate / 2;\n      var freqMin = my.frequencyMin;\n      var freqMax = my.frequencyMax;\n\n      if (!spectrCc) {\n        return;\n      }\n\n      var _loop = function _loop(c) {\n        // for each channel\n        var pixels = my.resample(frequenciesData[c]);\n        var imageData = new ImageData(width, height);\n\n        for (var i = 0; i < pixels.length; i++) {\n          for (var j = 0; j < pixels[i].length; j++) {\n            var colorMap = my.colorMap[pixels[i][j]];\n            var redIndex = ((height - j) * width + i) * 4;\n            imageData.data[redIndex] = colorMap[0] * 255;\n            imageData.data[redIndex + 1] = colorMap[1] * 255;\n            imageData.data[redIndex + 2] = colorMap[2] * 255;\n            imageData.data[redIndex + 3] = colorMap[3] * 255;\n          }\n        } // scale and stack spectrograms\n\n\n        createImageBitmap(imageData).then(function (renderer) {\n          return spectrCc.drawImage(renderer, 0, height * (1 - freqMax / freqFrom), // source x, y\n          width, height * (freqMax - freqMin) / freqFrom, // source width, height\n          0, height * c, // destination x, y\n          width, height // destination width, height\n          );\n        });\n      };\n\n      for (var c = 0; c < frequenciesData.length; c++) {\n        _loop(c);\n      }\n    }\n  }, {\n    key: \"getFrequencies\",\n    value: function getFrequencies(callback) {\n      var fftSamples = this.fftSamples;\n      var buffer = this.buffer = this.wavesurfer.backend.buffer;\n      var channels = this.channels;\n\n      if (!buffer) {\n        this.fireEvent('error', 'Web Audio buffer is not available');\n        return;\n      } // This may differ from file samplerate. Browser resamples audio.\n\n\n      var sampleRate = buffer.sampleRate;\n      var frequencies = [];\n      var noverlap = this.noverlap;\n\n      if (!noverlap) {\n        var uniqueSamplesPerPx = buffer.length / this.canvas.width;\n        noverlap = Math.max(0, Math.round(fftSamples - uniqueSamplesPerPx));\n      }\n\n      var fft = new _fft.default(fftSamples, sampleRate, this.windowFunc, this.alpha);\n\n      for (var c = 0; c < channels; c++) {\n        // for each channel\n        var channelData = buffer.getChannelData(c);\n        var channelFreq = [];\n        var currentOffset = 0;\n\n        while (currentOffset + fftSamples < channelData.length) {\n          var segment = channelData.slice(currentOffset, currentOffset + fftSamples);\n          var spectrum = fft.calculateSpectrum(segment);\n          var array = new Uint8Array(fftSamples / 2);\n          var j = void 0;\n\n          for (j = 0; j < fftSamples / 2; j++) {\n            array[j] = Math.max(-255, Math.log10(spectrum[j]) * 45);\n          }\n\n          channelFreq.push(array); // channelFreq: [sample, freq]\n\n          currentOffset += fftSamples - noverlap;\n        }\n\n        frequencies.push(channelFreq); // frequencies: [channel, sample, freq]\n      }\n\n      callback(frequencies, this);\n    }\n  }, {\n    key: \"loadFrequenciesData\",\n    value: function loadFrequenciesData(url) {\n      var _this2 = this;\n\n      var request = this.util.fetchFile({\n        url: url\n      });\n      request.on('success', function (data) {\n        return _this2.drawSpectrogram(JSON.parse(data), _this2);\n      });\n      request.on('error', function (e) {\n        return _this2.fireEvent('error', e);\n      });\n      return request;\n    }\n  }, {\n    key: \"freqType\",\n    value: function freqType(freq) {\n      return freq >= 1000 ? (freq / 1000).toFixed(1) : Math.round(freq);\n    }\n  }, {\n    key: \"unitType\",\n    value: function unitType(freq) {\n      return freq >= 1000 ? 'KHz' : 'Hz';\n    }\n  }, {\n    key: \"loadLabels\",\n    value: function loadLabels(bgFill, fontSizeFreq, fontSizeUnit, fontType, textColorFreq, textColorUnit, textAlign, container) {\n      var frequenciesHeight = this.height;\n      bgFill = bgFill || 'rgba(68,68,68,0)';\n      fontSizeFreq = fontSizeFreq || '12px';\n      fontSizeUnit = fontSizeUnit || '10px';\n      fontType = fontType || 'Helvetica';\n      textColorFreq = textColorFreq || '#fff';\n      textColorUnit = textColorUnit || '#fff';\n      textAlign = textAlign || 'center';\n      container = container || '#specLabels';\n      var bgWidth = 55;\n      var getMaxY = frequenciesHeight || 512;\n      var labelIndex = 5 * (getMaxY / 256);\n      var freqStart = this.frequencyMin;\n      var step = (this.frequencyMax - freqStart) / labelIndex; // prepare canvas element for labels\n\n      var ctx = this.labelsEl.getContext('2d');\n      var dispScale = window.devicePixelRatio;\n      this.labelsEl.height = this.height * this.channels * dispScale;\n      this.labelsEl.width = bgWidth * dispScale;\n      ctx.scale(dispScale, dispScale);\n\n      if (!ctx) {\n        return;\n      }\n\n      for (var c = 0; c < this.channels; c++) {\n        // for each channel\n        // fill background\n        ctx.fillStyle = bgFill;\n        ctx.fillRect(0, c * getMaxY, bgWidth, (1 + c) * getMaxY);\n        ctx.fill();\n        var i = void 0; // render labels\n\n        for (i = 0; i <= labelIndex; i++) {\n          ctx.textAlign = textAlign;\n          ctx.textBaseline = 'middle';\n          var freq = freqStart + step * i;\n          var label = this.freqType(freq);\n          var units = this.unitType(freq);\n          var yLabelOffset = 2;\n          var x = 16;\n          var y = void 0;\n\n          if (i == 0) {\n            y = (1 + c) * getMaxY + i - 10; // unit label\n\n            ctx.fillStyle = textColorUnit;\n            ctx.font = fontSizeUnit + ' ' + fontType;\n            ctx.fillText(units, x + 24, y); // freq label\n\n            ctx.fillStyle = textColorFreq;\n            ctx.font = fontSizeFreq + ' ' + fontType;\n            ctx.fillText(label, x, y);\n          } else {\n            y = (1 + c) * getMaxY - i * 50 + yLabelOffset; // unit label\n\n            ctx.fillStyle = textColorUnit;\n            ctx.font = fontSizeUnit + ' ' + fontType;\n            ctx.fillText(units, x + 24, y); // freq label\n\n            ctx.fillStyle = textColorFreq;\n            ctx.font = fontSizeFreq + ' ' + fontType;\n            ctx.fillText(label, x, y);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"updateScroll\",\n    value: function updateScroll(e) {\n      if (this.wrapper) {\n        this.wrapper.scrollLeft = e.target.scrollLeft;\n      }\n    }\n  }, {\n    key: \"resample\",\n    value: function resample(oldMatrix) {\n      var columnsNumber = this.width;\n      var newMatrix = [];\n      var oldPiece = 1 / oldMatrix.length;\n      var newPiece = 1 / columnsNumber;\n      var i;\n\n      for (i = 0; i < columnsNumber; i++) {\n        var column = new Array(oldMatrix[0].length);\n        var j = void 0;\n\n        for (j = 0; j < oldMatrix.length; j++) {\n          var oldStart = j * oldPiece;\n          var oldEnd = oldStart + oldPiece;\n          var newStart = i * newPiece;\n          var newEnd = newStart + newPiece;\n          var overlap = oldEnd <= newStart || newEnd <= oldStart ? 0 : Math.min(Math.max(oldEnd, newStart), Math.max(newEnd, oldStart)) - Math.max(Math.min(oldEnd, newStart), Math.min(newEnd, oldStart));\n          var k = void 0;\n          /* eslint-disable max-depth */\n\n          if (overlap > 0) {\n            for (k = 0; k < oldMatrix[0].length; k++) {\n              if (column[k] == null) {\n                column[k] = 0;\n              }\n\n              column[k] += overlap / newPiece * oldMatrix[j][k];\n            }\n          }\n          /* eslint-enable max-depth */\n\n        }\n\n        var intColumn = new Uint8Array(oldMatrix[0].length);\n        var m = void 0;\n\n        for (m = 0; m < oldMatrix[0].length; m++) {\n          intColumn[m] = column[m];\n        }\n\n        newMatrix.push(intColumn);\n      }\n\n      return newMatrix;\n    }\n  }], [{\n    key: \"create\",\n    value:\n    /**\n     * Spectrogram plugin definition factory\n     *\n     * This function must be used to create a plugin definition which can be\n     * used by wavesurfer to correctly instantiate the plugin.\n     *\n     * @param  {SpectrogramPluginParams} params Parameters used to initialise the plugin\n     * @return {PluginDefinition} An object representing the plugin.\n     */\n    function create(params) {\n      return {\n        name: 'spectrogram',\n        deferInit: params && params.deferInit ? params.deferInit : false,\n        params: params,\n        staticProps: {\n          FFT: _fft.default\n        },\n        instance: SpectrogramPlugin\n      };\n    }\n  }]);\n\n  return SpectrogramPlugin;\n}();\n\nexports[\"default\"] = SpectrogramPlugin;\nmodule.exports = exports.default;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \tvar __webpack_exports__ = __webpack_require__(\"./src/plugin/spectrogram/index.js\");\n/******/ \t\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});\n//# sourceMappingURL=wavesurfer.spectrogram.js.map","/*!\n * wavesurfer.js timeline plugin 6.2.0 (2022-05-16)\n * https://wavesurfer-js.org\n * @license BSD-3-Clause\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"WaveSurfer\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WaveSurfer\"] = factory();\n\telse\n\t\troot[\"WaveSurfer\"] = root[\"WaveSurfer\"] || {}, root[\"WaveSurfer\"][\"timeline\"] = factory();\n})(self, () => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ \"./src/plugin/timeline/index.js\":\n/*!**************************************!*\\\n  !*** ./src/plugin/timeline/index.js ***!\n  \\**************************************/\n/***/ ((module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * @typedef {Object} TimelinePluginParams\n * @desc Extends the `WavesurferParams` wavesurfer was initialised with\n * @property {!string|HTMLElement} container CSS selector or HTML element where\n * the timeline should be drawn. This is the only required parameter.\n * @property {number} notchPercentHeight=90 Height of notches in percent\n * @property {string} unlabeledNotchColor='#c0c0c0' The colour of the notches\n * that do not have labels\n * @property {string} primaryColor='#000' The colour of the main notches\n * @property {string} secondaryColor='#c0c0c0' The colour of the secondary\n * notches\n * @property {string} primaryFontColor='#000' The colour of the labels next to\n * the main notches\n * @property {string} secondaryFontColor='#000' The colour of the labels next to\n * the secondary notches\n * @property {number} labelPadding=5 The padding between the label and the notch\n * @property {?number} zoomDebounce A debounce timeout to increase rendering\n * performance for large files\n * @property {string} fontFamily='Arial'\n * @property {number} fontSize=10 Font size of labels in pixels\n * @property {?number} duration Length of the track in seconds. Overrides\n * getDuration() for setting length of timeline\n * @property {function} formatTimeCallback (sec, pxPerSec) -> label\n * @property {function} timeInterval (pxPerSec) -> seconds between notches\n * @property {function} primaryLabelInterval (pxPerSec) -> cadence between\n * labels in primary color\n * @property {function} secondaryLabelInterval (pxPerSec) -> cadence between\n * labels in secondary color\n * @property {?number} offset Offset for the timeline start in seconds. May also be\n * negative.\n * @property {?boolean} deferInit Set to true to manually call\n * `initPlugin('timeline')`\n */\n\n/**\n * Adds a timeline to the waveform.\n *\n * @implements {PluginClass}\n * @extends {Observer}\n * @example\n * // es6\n * import TimelinePlugin from 'wavesurfer.timeline.js';\n *\n * // commonjs\n * var TimelinePlugin = require('wavesurfer.timeline.js');\n *\n * // if you are using <script> tags\n * var TimelinePlugin = window.WaveSurfer.timeline;\n *\n * // ... initialising wavesurfer with the plugin\n * var wavesurfer = WaveSurfer.create({\n *   // wavesurfer options ...\n *   plugins: [\n *     TimelinePlugin.create({\n *       // plugin options ...\n *     })\n *   ]\n * });\n */\nvar TimelinePlugin = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of TimelinePlugin.\n   *\n   * You probably want to use TimelinePlugin.create()\n   *\n   * @param {TimelinePluginParams} params Plugin parameters\n   * @param {object} ws Wavesurfer instance\n   */\n  function TimelinePlugin(params, _ws) {\n    var _this = this;\n\n    _classCallCheck(this, TimelinePlugin);\n\n    _defineProperty(this, \"_onScroll\", function () {\n      if (_this.wrapper && _this.drawer.wrapper) {\n        _this.wrapper.scrollLeft = _this.drawer.wrapper.scrollLeft;\n      }\n    });\n\n    _defineProperty(this, \"_onRedraw\", function () {\n      return _this.render();\n    });\n\n    _defineProperty(this, \"_onReady\", function () {\n      var ws = _this.wavesurfer;\n      _this.drawer = ws.drawer;\n      _this.pixelRatio = ws.drawer.params.pixelRatio;\n      _this.maxCanvasWidth = ws.drawer.maxCanvasWidth || ws.drawer.width;\n      _this.maxCanvasElementWidth = ws.drawer.maxCanvasElementWidth || Math.round(_this.maxCanvasWidth / _this.pixelRatio); // add listeners\n\n      ws.drawer.wrapper.addEventListener('scroll', _this._onScroll);\n      ws.on('redraw', _this._onRedraw);\n      ws.on('zoom', _this._onZoom);\n\n      _this.render();\n    });\n\n    _defineProperty(this, \"_onWrapperClick\", function (e) {\n      e.preventDefault();\n      var relX = 'offsetX' in e ? e.offsetX : e.layerX;\n\n      _this.fireEvent('click', relX / _this.wrapper.scrollWidth || 0);\n    });\n\n    this.container = 'string' == typeof params.container ? document.querySelector(params.container) : params.container;\n\n    if (!this.container) {\n      throw new Error('No container for wavesurfer timeline');\n    }\n\n    this.wavesurfer = _ws;\n    this.util = _ws.util;\n    this.params = Object.assign({}, {\n      height: 20,\n      notchPercentHeight: 90,\n      labelPadding: 5,\n      unlabeledNotchColor: '#c0c0c0',\n      primaryColor: '#000',\n      secondaryColor: '#c0c0c0',\n      primaryFontColor: '#000',\n      secondaryFontColor: '#000',\n      fontFamily: 'Arial',\n      fontSize: 10,\n      duration: null,\n      zoomDebounce: false,\n      formatTimeCallback: this.defaultFormatTimeCallback,\n      timeInterval: this.defaultTimeInterval,\n      primaryLabelInterval: this.defaultPrimaryLabelInterval,\n      secondaryLabelInterval: this.defaultSecondaryLabelInterval,\n      offset: 0\n    }, params);\n    this.canvases = [];\n    this.wrapper = null;\n    this.drawer = null;\n    this.pixelRatio = null;\n    this.maxCanvasWidth = null;\n    this.maxCanvasElementWidth = null;\n    /**\n     * This event handler has to be in the constructor function because it\n     * relies on the debounce function which is only available after\n     * instantiation\n     *\n     * Use a debounced function if `params.zoomDebounce` is defined\n     *\n     * @returns {void}\n     */\n\n    this._onZoom = this.params.zoomDebounce ? this.wavesurfer.util.debounce(function () {\n      return _this.render();\n    }, this.params.zoomDebounce) : function () {\n      return _this.render();\n    };\n  }\n  /**\n   * Initialisation function used by the plugin API\n   */\n\n\n  _createClass(TimelinePlugin, [{\n    key: \"init\",\n    value: function init() {\n      // Check if ws is ready\n      if (this.wavesurfer.isReady) {\n        this._onReady();\n      } else {\n        this.wavesurfer.once('ready', this._onReady);\n      }\n    }\n    /**\n     * Destroy function used by the plugin API\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.unAll();\n      this.wavesurfer.un('redraw', this._onRedraw);\n      this.wavesurfer.un('zoom', this._onZoom);\n      this.wavesurfer.un('ready', this._onReady);\n      this.wavesurfer.drawer.wrapper.removeEventListener('scroll', this._onScroll);\n\n      if (this.wrapper && this.wrapper.parentNode) {\n        this.wrapper.removeEventListener('click', this._onWrapperClick);\n        this.wrapper.parentNode.removeChild(this.wrapper);\n        this.wrapper = null;\n      }\n    }\n    /**\n     * Create a timeline element to wrap the canvases drawn by this plugin\n     *\n     */\n\n  }, {\n    key: \"createWrapper\",\n    value: function createWrapper() {\n      var wsParams = this.wavesurfer.params;\n      this.container.innerHTML = '';\n      this.wrapper = this.container.appendChild(document.createElement('timeline'));\n      this.util.style(this.wrapper, {\n        display: 'block',\n        position: 'relative',\n        userSelect: 'none',\n        webkitUserSelect: 'none',\n        height: \"\".concat(this.params.height, \"px\")\n      });\n\n      if (wsParams.fillParent || wsParams.scrollParent) {\n        this.util.style(this.wrapper, {\n          width: '100%',\n          overflowX: 'hidden',\n          overflowY: 'hidden'\n        });\n      }\n\n      this.wrapper.addEventListener('click', this._onWrapperClick);\n    }\n    /**\n     * Render the timeline (also updates the already rendered timeline)\n     *\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      if (!this.wrapper) {\n        this.createWrapper();\n      }\n\n      this.updateCanvases();\n      this.updateCanvasesPositioning();\n      this.renderCanvases();\n    }\n    /**\n     * Add new timeline canvas\n     *\n     */\n\n  }, {\n    key: \"addCanvas\",\n    value: function addCanvas() {\n      var canvas = this.wrapper.appendChild(document.createElement('canvas'));\n      this.canvases.push(canvas);\n      this.util.style(canvas, {\n        position: 'absolute',\n        zIndex: 4\n      });\n    }\n    /**\n     * Remove timeline canvas\n     *\n     */\n\n  }, {\n    key: \"removeCanvas\",\n    value: function removeCanvas() {\n      var canvas = this.canvases.pop();\n      canvas.parentElement.removeChild(canvas);\n    }\n    /**\n     * Make sure the correct of timeline canvas elements exist and are cached in\n     * this.canvases\n     *\n     */\n\n  }, {\n    key: \"updateCanvases\",\n    value: function updateCanvases() {\n      var totalWidth = Math.round(this.drawer.wrapper.scrollWidth);\n      var requiredCanvases = Math.ceil(totalWidth / this.maxCanvasElementWidth);\n\n      while (this.canvases.length < requiredCanvases) {\n        this.addCanvas();\n      }\n\n      while (this.canvases.length > requiredCanvases) {\n        this.removeCanvas();\n      }\n    }\n    /**\n     * Update the dimensions and positioning style for all the timeline canvases\n     *\n     */\n\n  }, {\n    key: \"updateCanvasesPositioning\",\n    value: function updateCanvasesPositioning() {\n      var _this2 = this;\n\n      // cache length for performance\n      var canvasesLength = this.canvases.length;\n      this.canvases.forEach(function (canvas, i) {\n        // canvas width is the max element width, or if it is the last the\n        // required width\n        var canvasWidth = i === canvasesLength - 1 ? _this2.drawer.wrapper.scrollWidth - _this2.maxCanvasElementWidth * (canvasesLength - 1) : _this2.maxCanvasElementWidth; // set dimensions and style\n\n        canvas.width = canvasWidth * _this2.pixelRatio; // on certain pixel ratios the canvas appears cut off at the bottom,\n        // therefore leave 1px extra\n\n        canvas.height = (_this2.params.height + 1) * _this2.pixelRatio;\n\n        _this2.util.style(canvas, {\n          width: \"\".concat(canvasWidth, \"px\"),\n          height: \"\".concat(_this2.params.height, \"px\"),\n          left: \"\".concat(i * _this2.maxCanvasElementWidth, \"px\")\n        });\n      });\n    }\n    /**\n     * Render the timeline labels and notches\n     *\n     */\n\n  }, {\n    key: \"renderCanvases\",\n    value: function renderCanvases() {\n      var _this3 = this;\n\n      var duration = this.params.duration || this.wavesurfer.backend.getDuration();\n\n      if (duration <= 0) {\n        return;\n      }\n\n      var wsParams = this.wavesurfer.params;\n      var fontSize = this.params.fontSize * wsParams.pixelRatio;\n      var totalSeconds = parseInt(duration, 10) + 1;\n      var width = wsParams.fillParent && !wsParams.scrollParent ? this.drawer.getWidth() : this.drawer.wrapper.scrollWidth * wsParams.pixelRatio;\n      var height1 = this.params.height * this.pixelRatio;\n      var height2 = this.params.height * (this.params.notchPercentHeight / 100) * this.pixelRatio;\n      var pixelsPerSecond = width / duration;\n      var formatTime = this.params.formatTimeCallback; // if parameter is function, call the function with\n      // pixelsPerSecond, otherwise simply take the value as-is\n\n      var intervalFnOrVal = function intervalFnOrVal(option) {\n        return typeof option === 'function' ? option(pixelsPerSecond) : option;\n      };\n\n      var timeInterval = intervalFnOrVal(this.params.timeInterval);\n      var primaryLabelInterval = intervalFnOrVal(this.params.primaryLabelInterval);\n      var secondaryLabelInterval = intervalFnOrVal(this.params.secondaryLabelInterval);\n      var curPixel = pixelsPerSecond * this.params.offset;\n      var curSeconds = 0;\n      var i; // build an array of position data with index, second and pixel data,\n      // this is then used multiple times below\n\n      var positioning = []; // render until end in case we have a negative offset\n\n      var renderSeconds = this.params.offset < 0 ? totalSeconds - this.params.offset : totalSeconds;\n\n      for (i = 0; i < renderSeconds / timeInterval; i++) {\n        positioning.push([i, curSeconds, curPixel]);\n        curSeconds += timeInterval;\n        curPixel += pixelsPerSecond * timeInterval;\n      } // iterate over each position\n\n\n      var renderPositions = function renderPositions(cb) {\n        positioning.forEach(function (pos) {\n          cb(pos[0], pos[1], pos[2]);\n        });\n      }; // render primary labels\n\n\n      this.setFillStyles(this.params.primaryColor);\n      this.setFonts(\"\".concat(fontSize, \"px \").concat(this.params.fontFamily));\n      this.setFillStyles(this.params.primaryFontColor);\n      renderPositions(function (i, curSeconds, curPixel) {\n        if (i % primaryLabelInterval === 0) {\n          _this3.fillRect(curPixel, 0, 1, height1);\n\n          _this3.fillText(formatTime(curSeconds, pixelsPerSecond), curPixel + _this3.params.labelPadding * _this3.pixelRatio, height1);\n        }\n      }); // render secondary labels\n\n      this.setFillStyles(this.params.secondaryColor);\n      this.setFonts(\"\".concat(fontSize, \"px \").concat(this.params.fontFamily));\n      this.setFillStyles(this.params.secondaryFontColor);\n      renderPositions(function (i, curSeconds, curPixel) {\n        if (i % secondaryLabelInterval === 0) {\n          _this3.fillRect(curPixel, 0, 1, height1);\n\n          _this3.fillText(formatTime(curSeconds, pixelsPerSecond), curPixel + _this3.params.labelPadding * _this3.pixelRatio, height1);\n        }\n      }); // render the actual notches (when no labels are used)\n\n      this.setFillStyles(this.params.unlabeledNotchColor);\n      renderPositions(function (i, curSeconds, curPixel) {\n        if (i % secondaryLabelInterval !== 0 && i % primaryLabelInterval !== 0) {\n          _this3.fillRect(curPixel, 0, 1, height2);\n        }\n      });\n    }\n    /**\n     * Set the canvas fill style\n     *\n     * @param {DOMString|CanvasGradient|CanvasPattern} fillStyle Fill style to\n     * use\n     */\n\n  }, {\n    key: \"setFillStyles\",\n    value: function setFillStyles(fillStyle) {\n      this.canvases.forEach(function (canvas) {\n        var context = canvas.getContext('2d');\n\n        if (context) {\n          context.fillStyle = fillStyle;\n        }\n      });\n    }\n    /**\n     * Set the canvas font\n     *\n     * @param {DOMString} font Font to use\n     */\n\n  }, {\n    key: \"setFonts\",\n    value: function setFonts(font) {\n      this.canvases.forEach(function (canvas) {\n        var context = canvas.getContext('2d');\n\n        if (context) {\n          context.font = font;\n        }\n      });\n    }\n    /**\n     * Draw a rectangle on the canvases\n     *\n     * (it figures out the offset for each canvas)\n     *\n     * @param {number} x X-position\n     * @param {number} y Y-position\n     * @param {number} width Width\n     * @param {number} height Height\n     */\n\n  }, {\n    key: \"fillRect\",\n    value: function fillRect(x, y, width, height) {\n      var _this4 = this;\n\n      this.canvases.forEach(function (canvas, i) {\n        var leftOffset = i * _this4.maxCanvasWidth;\n        var intersection = {\n          x1: Math.max(x, i * _this4.maxCanvasWidth),\n          y1: y,\n          x2: Math.min(x + width, i * _this4.maxCanvasWidth + canvas.width),\n          y2: y + height\n        };\n\n        if (intersection.x1 < intersection.x2) {\n          var context = canvas.getContext('2d');\n\n          if (context) {\n            context.fillRect(intersection.x1 - leftOffset, intersection.y1, intersection.x2 - intersection.x1, intersection.y2 - intersection.y1);\n          }\n        }\n      });\n    }\n    /**\n     * Fill a given text on the canvases\n     *\n     * @param {string} text Text to render\n     * @param {number} x X-position\n     * @param {number} y Y-position\n     */\n\n  }, {\n    key: \"fillText\",\n    value: function fillText(text, x, y) {\n      var textWidth;\n      var xOffset = 0;\n      this.canvases.forEach(function (canvas) {\n        var context = canvas.getContext('2d');\n\n        if (context) {\n          var canvasWidth = context.canvas.width;\n\n          if (xOffset > x + textWidth) {\n            return;\n          }\n\n          if (xOffset + canvasWidth > x && context) {\n            textWidth = context.measureText(text).width;\n            context.fillText(text, x - xOffset, y);\n          }\n\n          xOffset += canvasWidth;\n        }\n      });\n    }\n    /**\n     * Turn the time into a suitable label for the time.\n     *\n     * @param {number} seconds Seconds to format\n     * @param {number} pxPerSec Pixels per second\n     * @returns {number} Time\n     */\n\n  }, {\n    key: \"defaultFormatTimeCallback\",\n    value: function defaultFormatTimeCallback(seconds, pxPerSec) {\n      if (seconds / 60 > 1) {\n        // calculate minutes and seconds from seconds count\n        var minutes = parseInt(seconds / 60, 10);\n        seconds = parseInt(seconds % 60, 10); // fill up seconds with zeroes\n\n        seconds = seconds < 10 ? '0' + seconds : seconds;\n        return \"\".concat(minutes, \":\").concat(seconds);\n      }\n\n      return Math.round(seconds * 1000) / 1000;\n    }\n    /**\n     * Return how many seconds should be between each notch\n     *\n     * @param {number} pxPerSec Pixels per second\n     * @returns {number} Time\n     */\n\n  }, {\n    key: \"defaultTimeInterval\",\n    value: function defaultTimeInterval(pxPerSec) {\n      if (pxPerSec >= 25) {\n        return 1;\n      } else if (pxPerSec * 5 >= 25) {\n        return 5;\n      } else if (pxPerSec * 15 >= 25) {\n        return 15;\n      }\n\n      return Math.ceil(0.5 / pxPerSec) * 60;\n    }\n    /**\n     * Return the cadence of notches that get labels in the primary color.\n     *\n     * @param {number} pxPerSec Pixels per second\n     * @returns {number} Cadence\n     */\n\n  }, {\n    key: \"defaultPrimaryLabelInterval\",\n    value: function defaultPrimaryLabelInterval(pxPerSec) {\n      if (pxPerSec >= 25) {\n        return 10;\n      } else if (pxPerSec * 5 >= 25) {\n        return 6;\n      } else if (pxPerSec * 15 >= 25) {\n        return 4;\n      }\n\n      return 4;\n    }\n    /**\n     * Return the cadence of notches that get labels in the secondary color.\n     *\n     * @param {number} pxPerSec Pixels per second\n     * @returns {number} Cadence\n     */\n\n  }, {\n    key: \"defaultSecondaryLabelInterval\",\n    value: function defaultSecondaryLabelInterval(pxPerSec) {\n      if (pxPerSec >= 25) {\n        return 5;\n      } else if (pxPerSec * 5 >= 25) {\n        return 2;\n      } else if (pxPerSec * 15 >= 25) {\n        return 2;\n      }\n\n      return 2;\n    }\n  }], [{\n    key: \"create\",\n    value:\n    /**\n     * Timeline plugin definition factory\n     *\n     * This function must be used to create a plugin definition which can be\n     * used by wavesurfer to correctly instantiate the plugin.\n     *\n     * @param  {TimelinePluginParams} params parameters use to initialise the plugin\n     * @return {PluginDefinition} an object representing the plugin\n     */\n    function create(params) {\n      return {\n        name: 'timeline',\n        deferInit: params && params.deferInit ? params.deferInit : false,\n        params: params,\n        instance: TimelinePlugin\n      };\n    } // event handlers\n\n  }]);\n\n  return TimelinePlugin;\n}();\n\nexports[\"default\"] = TimelinePlugin;\nmodule.exports = exports.default;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \tvar __webpack_exports__ = __webpack_require__(\"./src/plugin/timeline/index.js\");\n/******/ \t\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});\n//# sourceMappingURL=wavesurfer.timeline.js.map"],"names":[],"sourceRoot":""}